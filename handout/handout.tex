\documentclass[letterpaper, 12pt, titlepage, twoside]{article}
\input setup

\title{A Whirlwind Tour of Programming in Python}
\author{P. K. G. Williams (\href{mailto:peter@newton.cx}{peter@newton.cx})}
\date{\today \\ version \t{\gitversion}}

\begin{document}
\maketitle

\section*{Introduction\markboth{Introduction}{}}

This handout accompanies a 90-minute introduction into computer programming
using the \href{https://www.python.org/}{Python} language. It is intended for
students who have never programmed a computer using a formal language before,
although we hope that some of the ideas we present will be interesting to more
experienced students as well.

It is \i{totally impossible} to teach anything but the most superficial
elements of the Python language or the principles of computer science in
90~minutes.

Given that reality, for this lesson we have chosen to just \i{visit} a few
topics that are important to the craft of writing software and illustrate them
with some \i{extremely limited} examples in Python. Our treatments of both the
``big picture'' ideas \i{and} the basics of writing Python programs will be
dissatisfying. We hope, however, that this lesson will plant seeds that will
grow over time.

Due to the context in which this lesson was written, it is aimed at
\i{version~2} of Python, not version~3. Students are expected to have a laptop
available that is running the interactive \href{https://jupyter.org/}{Jupyter}
notebook. The lesson is divided into seven activities, each of which has a
``mini-lecture'' component and a hands-on component. Each activity is intended
to take about 15~minutes to complete.


\newpage
\section{Foundations}

In this hands-on activity, we'll just make sure that you can get Jupyter
running and show you some basics about how to run commands in a Jupyter
notebook. Because we're just getting started, there's a lot more explanatory
text than you'll find in the other activities.

If you haven't already, start Jupyter and create a new, empty notebook. We've
written this lesson assuming that you've already seen how to do this --- ask
for help from a neighbor or a helper if not, or if you run into any problems.

In this handout, text styled the following way is code that you should type
into your notebook.

\begin{lstlisting}
  print 'Hello, world!'
  x = 1
\end{lstlisting}

Type this code now, \i{exactly} as it is shown here --- be careful with
punctuation and spaces. When using Jupyter, start new lines of code by just
hitting the \s{Enter} key as usual.

(By the way, we are \i{very intentionally} forcing you to type this code
yourself! You'll have to type a lot of code yourself eventually; might as well
start now.)

To actually \i{run} the block of code that you have just typed, type
\s{Shift-Enter} (that is, the \s{Enter} key with the \s{Shift} key also held
down). You should see the message ``Hello, world!'' appear and a new block for
code entry appear. Each of these blocks is a \i{cell} in your notebook.

The horizontal bars delimit pieces of code that you should type in separate
cells, typing \s{Shift-Enter} at the end of each cell. For instance:

\begin{lstlisting}
  x
\end{lstlisting}
\begin{lstlisting}
  y = 1.6
  y
\end{lstlisting}

This means that you should type these two pieces code in separate cells,
running the first one before you start typing the second one. Do so now. You
should see the values ``1'' and ``1.6'' printed back at you.

\i{From here on out, if you see a code listing as above, always assume that
  you should type it in and run it in your notebook. Skipping cells might
  cause later demonstrations to fail.}

There is an exception to our request that you type things precisely as
written. Sometimes we'll write some explanatory text as Python \i{comments}.
These are delimited with hash signs (\s{\#}). In these activities you don't
need to type the comments. When there's a line with a \s{\#}, skip it and
everything that comes after it.

\begin{lstlisting}
  x = 7 #<== don't bother typing this or anything after it
  x
\end{lstlisting}

Every so often we intentionally have you type a command that results in an
error. We will indicate this with a comment about ``raising'' a particular
kind of error:

\begin{lstlisting}
  assert x == 2 # !!! raises AssertionError
\end{lstlisting}

Running this line should produce some red text and technical information
indicating an error. Eventually you should learn how to make sense of the
information, but we'll ignore it for now.

\i{Only} lines with these ``raise'' annotations should result in error
messages. These lines will come at the ends of cells, since any code within a
cell that comes after an error will not be run. If some other line of code
causes an error, something has gone wrong and you should ask a neighbor or
helper to take a look.

Because of the limited time available, we're going to have to ask you to do a
lot of ``monkey see, monkey do'' coding: we'll have you type in code without
giving you a fair chance to be able to understand it. For instance, type and
run this code, \i{making sure to reproduce the spaces after the \s{while}
  keyword}:

\begin{lstlisting}
  import pylab as pl
  import numpy as np
  i = 99
  x, y = np.mgrid[-2:2:999j, -2:2:999j]
  c = z = x * 1j + y
  while i:
      x[np.abs(z) > 2] = i
      z = z * z + c
      i -= 1
  pl.show(pl.imshow(x))
\end{lstlisting}

If you've done this right, you'll see some warning messages get printed in
red, and then an image of the Mandlebrot set will appear after a few seconds.
You might have to scroll your notebook down to see everything.

The demo above might be neat, but we recognize that it is not very
instructive, if not actively frustrating, for most people. Apologies --- we
have made a choice to try to expose you to several big ideas about
programming, at the expense of building a solid foundation for those ideas.

But a foundation is essential! We recommend a textbook, \i{How to Think Like a
  Computer Scientist: Learning with Python}, by Allen Downey, Jeffrey Elkner,
and Chris Meyers. Download it here for free:

\begin{center}
  \url{http://www.greenteapress.com/thinkpython/thinkCSpy/thinkCSpy.pdf}
\end{center}

Download it now and save it on your computer. Your homework is to \i{start
  reading the textbook}. The end of this handout points you to a variety of
other resources aimed at helping people learn to code using Python.

One last thing: we do not have you create much code from scratch in this
lesson, but feel free to experiment as you go. Students often come to us with
a piece of code and ask, ``Will this work?'' To which we always reply, ``Just
try running it and find out!'' \i{The worst that can happen is that it won't
  work}. Which isn't so bad, is it? Python and Jupyter are great for
experimentation --- take advantage of it!


\newpage
\section{Data structures}

In this activity we will practice creating various kinds of Python data
objects and try to demonstrate how the ideas of \i{indirection} and
\i{mutability} are important in computing.

\subsection*{Foundational data types; printing your data}

Assign some values of different types to some variables:

\begin{lstlisting}
  a_none_variable = None
  negative_int = -100
  one_million = 1e6 # "exponential" notation for floats: = 1 * 10**6
  a_string = 'Using python'
\end{lstlisting}

\i{When using the Jupyter notebook}, if you just type in a variable's name in
a cell and hit \s{Shift-Enter}, you will be shown the current value of that
variable:

\begin{lstlisting}
  one_million
\end{lstlisting}

It is very important and valuable to examine your variables as you manipulate
them. \i{When in doubt, print it out!} It never hurts.

If you want to look at multiple variables, you have to put each one's name in
a different cell:

\begin{lstlisting}
  one_million # does not reappear
  a_string
\end{lstlisting}

You can do math with numeric variables by typing in standard mathematical
notation. Multiplication is expressed with a single asterisk (\s{*}).
Exponentiation ($a^b$) is written with a double asterisk (\s{a**b}).

\begin{lstlisting}
  new_number = one_million / negative_int
  other_number = (new_number * 0.01) + 5**2
  other_number
\end{lstlisting}

Lots of coders end up typing their math densely for some reason: \s{(5*i)+3}
instead of \s{(5 * i) + 3}. This is ridiculous. Spaces make things easier to
read! And they are free! Hit the spacebar liberally.

\subsection*{Lists}

As presented in the mini-lecture, Python's \i{lists} are ordered sequences of
other data. Lists can hold any kind of data.

\begin{lstlisting}
  list_of_ints = [1, 2, 5]
  mixed_list = ['Hello', one_million, list_of_ints]
  mixed_list
\end{lstlisting}

Unlike the basic data types, lists are mutable --- you can modify their
contents. We do this by \i{indexing} the list, using square brackets to
identify a specific one of its \i{elements} (or \i{items}) that we care about,
rather than the whole list at once:

\begin{lstlisting}
  list_of_ints[1] = 3
  list_of_ints
\end{lstlisting}

There might be something surprising about what just got printed out. We now
present you with one of the first mystical secrets of programming:

\medskip
\begin{center}
  \fbox{\Large The ``first'' element in a list has an index of zero, not one!}
\end{center}
\medskip

Every single person who starts out programming has trouble getting used to
this. Rest assured: there are very good reasons for this convention $\ldots$
but not so good that we think they'll be compelling just yet.

\begin{lstlisting}
  list_of_ints[0]
\end{lstlisting}

\begin{lstlisting}
  list_of_ints[2]
\end{lstlisting}

\subsection*{Indirection; mutability}

In the mini-lecture, we tried to emphasize that when you assign a variable,
you are creating a name that lets you refer to some piece of data. The name
and the data are not the same!

The following classic example demonstrates the point. Try hard to understand
what's going on here.

\begin{lstlisting}
  my_list = [1, 2, 3]
  print 'Before:', my_list
  other_list = my_list
  other_list[1] = 37
  print 'After:', my_list
\end{lstlisting}

The ``before'' and ``after'' values of \s{my\_list} are different, even though
it didn't \i{look} like you did anything to it! But while the variables
\s{my\_list} and \s{other\_list} might have different names, they both refer
to the same piece of data. So altering \s{other\_list} --- that is, the piece
of data referenced by the variable \s{other\_list} --- alters \s{my\_list} as
well.

Please note that \i{this kind of surprise can only happen because lists are
  mutable.} This is one reason that mutable data should be handled carefully.
If you share a mutable piece of data in two different pieces of code, it is
all too easy to run into problems because an alteration in one piece wasn't
intended to affect the other piece, but did anyway. In complex programs these
problems can be \i{very} difficult to track down.

\subsection*{Tuples}

In fact, Python specifically provides immutable versions of some of its data
structures. The immutable version of a list is called a \i{tuple}. They are
written down like lists, but with parentheses instead of square brackets.
However, in a surprising number of cases the parentheses are actually
optional!

\begin{lstlisting}
  a_tuple = (0, 3, 4)
  equivalent_tuple = 0, 3, 4 # this is fine; parens not actually needed
  other_tuple = (a_tuple, 'hello', my_list)
  other_tuple
\end{lstlisting}

You should sense that mutability must be important, if Python bothers to
provide two data types that are essentially identical \i{except} for their
mutability.

It gets more complicated, though, because tuples themselves are like named
variables: they only refer to their contents \i{indirectly}. So while you
can't change a tuple, if that tuple happens to contain a mutable variable, the
tuple can appear to change:

\begin{lstlisting}
  print 'Before:', other_tuple
  my_list[0] = -1234
  print 'After:', other_tuple
\end{lstlisting}

You might be starting to see why indirection has caused headaches for so many
programmers over the years!


\newpage
\section{Control Flow}

\def\typeit{$\pmb\mapsto$\space}

In this activity we will explore some of Python's constructs for controlling
program flow and think about ways to keep the flow clear.

To demonstrate these concepts, we are going to step away from Jupyter and
instead use an interactive debugger called PuDB. Below, sentences beginning
with \fbox{\typeit} are ones that tell you what to type.

\subsection*{Conditionals}

Start by opening a new terminal window. \typeit Run the following command in
your terminal:

\typeone{pudb control-flow.py}{Launch PuDB on our script.}

PuDB uses a semi-graphical interface in your terminal. It's not intuitive to
use, but we'll try to walk you through it carefully. Avoid hitting extraneous
keys, though, since you might put PuDB in a mode where our pre-written
instructions stop working.

When you launch it, PuDB will open a welcome message. You don't need to read
it. \typeit Hit \s{Enter} to make it go away.

You will then get a window showing preferences you can change. The defaults
are fine. \typeit Hit the right arrow key to highlight the \s{OK} box, then
\s{Enter} to close the window.

PuDB will now show you a screen with a lot of sections that are mostly empty.
It has loaded up our demo script and paused it on the first line. \typeit Hit
the \s{n} key to run the program one step, so that it advances to the
\underline{n}ext line.

You'll see that in the ``Variables'' display, in the top-right of your screen,
a line saying \fbox{\s{x: 0}} has appeared, because our program just assigned
the variable \s{x} the value 0. In the main window, the indicator has advanced
to the next non-blank line, an \s{if} statement, showing us where the program
is paused.

Take a moment to guess how control will flow over the next few lines. \typeit
Once you've done so, hit the \s{n} key a few more times \i{until you get to
  the line labeled ``pause point~A.''} Stop there. Were you right?

We'll now restart the program, without bothering to let it finish. \typeit Do
this by hitting the \s{q} key to open the ``Finished'' window, then hitting
\s{Enter}.

\typeit Hit the \s{n} key once to advance to the \s{if} statement once again.
\typeit Now, type \s{Control-x}. The screen will recolor, showing that now the
``Command line'' section in the lower-left part of the screen is active.

\typeit Type \s{x = 7} in the command line, then hit \s{Enter}. \typeit Then
hit \s{Control-x} again, which returns the ``focus'' of the program to the
main program listing. \typeit Finally, hit \s{n} to advance to the next line.
In the ``Variables'' display, you should see that \s{x} has changed to 7 ---
we were able to monkey with it interactively, while our program was running!
Fun! \typeit Hit \s{n} again to get to pause point~A.

\subsection*{Loops}

We'll now navigate through a few loops to help you get a feel for them. The
first \i{stanza} of code, going up until ``pause point~B'', calculates the
greatest common denominator (GCD) of two numbers --- although you might have
to trust us on this point. The expression \s{a \%\ b} computes the remainder
of $a$ divided by $b$.

\typeit Hit \s{n} and watch the variables change until you reach ``pause
point~B.'' The \s{while} loop doesn't have any complicated internal structure,
so the control flow is pretty simple here.

The next stanza has an admittedly nonsensical \s{for} loop that invokes the
\s{break} and \s{continue} statements. \typeit Hit \s{n} to step through the
loop. At the beginning of each iteration, consider the values of the variables
\s{z} and \s{k} and predict how the program's control flow will progress.
\typeit Proceed with \s{n} until you reach ``pause point~C.''

\subsection*{Avoiding rightward drift}

The control flow throughout a program should, ideally, be fairly
straightforward, and one should be able to get a sense of it from skimming the
code. The syntax of the Python language generally encourages this.

However, when you're writing code for not-so-simple computations, it is easy
for the control flow to get hard to follow. For instance, consider the next
stanza of code in our demonstration file. Given a span of time measured in
seconds, it converts it into an English string describing that span of time,
ranging from ``seconds'' all the way to ``years.''

To give you a chance to experiment with how the code works, we've implemented
this conversion in a loop. Each iteration, the code considers the variable
\s{seconds} and places the English description of the time span in the
variable \s{msg}.

\typeit Press \s{n} to step through one full iteration of the loop. You'll see
the control flow jump around as the necessary numbers are computed.

We think that you'll agree that the logic in this code is hard to follow at a
glance --- the \s{else} statements are widely separated from the \s{if}
statements, and the indentation gets deeply nested. Each level of indentation
brings with it a piece of context that you have to remember when reading the
code, which makes it confusing. In real programs, logic is often \i{not}
simple, and it's easy to get this kind of deep nesting --- a phenomenon called
\i{rightward drift}.

\typeit At the top of the loop, you can use \s{Control-x} to change the value
of the \s{seconds} variable to try out different settings, using \s{n} to step
through the code. When you've seen enough, use \s{Control-x} to change the
value of \s{keep\_going} to \s{False}. \i{The loop won't exit until you do
  this!} Move ahead to pause point~D.

In the next stanza of code, we implement the same logic. But this time, we use
\s{continue} statements to avoid rightward drift. While the two pieces of code
have identical functionality, we believe that this version is \i{much} easier
to read.

\typeit Step through the loop a few more times, using \s{Control-x} to try out
different values of \s{seconds} and eventually exiting by setting
\s{keep\_going} to \s{False}. When you're all done, type \s{q} \i{twice} to
exit PuDB.

Sophisticated programmers use statements like \s{continue} to keep their
control flow tidy and avoid rightward drift.


\newpage
\section{Input and Output (``IO'')}

We will now try out some basic IO in Python and explore the ``streaming''
model for data sets.

For this hands-on activity, return to your Jupyter notebook.

\subsection*{The \s{print} statement}

We've already encountered one form of IO: the \s{print} statement. It turns
your Python data into strings and prints them to your Jupyter notebook or, if
you're writing a command-line program, to your terminal.

Here's an \i{important disclaimer:} in Python~3, \s{print()} is a function,
not a special statement. This is a much, much better way to do things, but it
is not compatible with Python~2, and this fact makes it very annoying to port
code from version~2 to version~3. \i{\underline{TODO}: a good tutorial on the
  print\_function future import!}. For annoying technical reasons, that's not
a good solution for today, so we stick with the old-fashioned statement form
of \s{print}.

The \s{print} statement is usually very straightforward:

\begin{lstlisting}
  x = 4
  print 'x = ', x
\end{lstlisting}

It takes a comma-separated list of values, converts them into text, and prints
them all on a line, separated by spaces. The fact that it only separates
things with spaces can get a little annoying if you want to print out several
variables at once. Here's our recommended pattern for doing so:

\begin{lstlisting}
  y = 17
  z = 3.14
  print '(x, y, z) =', (x, y, z)
\end{lstlisting}

This approach doesn't require you to type that many quotes or parentheses. It
is tempting to just write statements like \s{print x, y, z}, but trust us:
printing numbers without hints as to their context gets confusing quickly.

\subsection*{IO with files}

The built-in \s{open()} function opens regular files on your computer's hard
disk for input or output. We refer to the file's \i{open mode} as either being
\i{read} or \i{write} depending on what you're going to do with it. The mode
is denoted with a special string argument that is passed to \s{open()}.

\begin{lstlisting}
  f = open('mydata.txt', 'w') # the "w" means to open for writing
\end{lstlisting}

The \s{open()} function returns a new form of Python data, an \i{object} --- a
\i{file object}, to be specific. These objects are their own type, different
than floats, lists, etc.

File objects, and almost all other Python objects, come with functions
attached to them. You can access and call these functions using ``dot syntax''
as shown below. In the first line, \s{write()} is a special function --- a
\i{method} --- that operates on the variable \s{f}. Here the
\s{'\textbackslash n'} bit of the string is a special ``escape code'' that
indicates that a new line of output should start.

\begin{lstlisting}
  f.write('Here is some text.\n')
  another_name_for_f = f
  another_name_for_f.write('Here is more text.\n')
\end{lstlisting}

There is a special way to invoke the \s{print} statement that prints data to a
file instead of to the terminal:

\begin{lstlisting}
  print >>f, 'The value of x is', x
\end{lstlisting}

When you're done with a file that you've opened, close it:

\begin{lstlisting}
  f.close()
\end{lstlisting}

Once you've closed a file, the \s{f} variable is in a bit of a funny state:
the variable still exists, but it's illegal to do anything with it:

\begin{lstlisting}
  print >>f, 'This will fail' # !!! raises ValueError
\end{lstlisting}

There's no need to assign the result of the \s{open()} function to a variable
if we're not going to keep it around for long. Therefore, to print the
contents of the file we just wrote, we can just do this:

\begin{lstlisting}
  print open('mydata.txt', 'r').read()
\end{lstlisting}

Here we are being naughty and not calling \s{close()} on the file object;
that's forgivable if you're just reading the file in one go.

%%One reason that it's important to close files is \i{buffering}: for efficiency
%%reason, Python will not actually write data to disk every time you issue a
%%\s{print} or \s{write()} command. The last data in your file are very unlikely
%%to actually show up until you issue the \s{close()} call. While Python will
%%eventually write out your data if you forget the \s{close()}, including it
%%gives you precise control over when this happens.
%%
%%The above is just one example of the subtleties that arise when doing IO.
%%There are \i{many} more. What happens when two programs try to write to the
%%same file? What happens when the file is accessed over a network and the
%%network goes down? What happens if a file is deleted while you're reading it?
%%The answers to these questions are defined by the underlying operating system,
%%not Python. Since every useful program has to do IO, it is \i{very} worthwhile
%%to spend time learning about the fundamental rules of IO on Unix-like
%%operating systems.

\subsection*{Network IO}

Thanks to the infrastructure that Python provides, reading and writing over
the network is almost as easy as reading and writing files from the local hard
disk. For instance, saving a file from the internet to disk takes just a few
lines of code:

\begin{lstlisting}
  from urllib2 import urlopen
  from shutil import copyfileobj
  source = urlopen('http://tinyurl.com/l66kod5')
  dest = open('datatable.txt', 'w')
  copyfileobj(source, dest)
  source.close()
  dest.close()
\end{lstlisting}

Above, the first two lines load standard Python \i{modules} that provide
pre-packaged routines that allow us to avoid a lot of work that we'd otherwise
have to do ourselves.

This cell probably took a half-second to run, since your notebook actually
connected to the internet and fetched a file. While we didn't see any
reassuring output, fear not: if no error message popped up, your download
succeeded!

\subsection*{High-Level IO}

The \s{print} statement is useful but it is not a good solution for anything
other than ad-hoc diagnostics and messages intended for users.

For more important data, it is better to choose a preexisting, standard data
format that is suited to the data. There is a Python module to read or write
essentially any data format you can think of.

For instance, the file we just downloaded contains data in the textual table
format developed by the Centre de Donn√©es astronomiques de Strasbourg (CDS).
The popular Python module \href{http://www.astropy.org/}{AstroPy} can read
these files into customized table data objects.

\begin{lstlisting}
  from astropy.io import ascii
  table = ascii.read('datatable.txt')
  table
\end{lstlisting}

Here, the AstroPy table object has special integration with Jupyter so that
when we display its value in the notebook, you get a fancy representation of
the table contents. Pretty fancy results for just 10 lines of code!

\subsection*{Streaming}

When doing IO with data sets, it is good to try to deal with them in a
\i{streaming} fashion when possible. That is, to process data as you work
through a file, rather than reading in the whole file at once. Streaming is
more efficient and flexible, and often just as easy to implement.

For instance, to loop through the lines in a text file, some people will write
code like this:

\begin{lstlisting}
  f = open('mydata.txt') # if you don't specify the mode, it defaults to 'r'
  data = f.read()
  lines = data.splitlines()
  f.close()

  for line in lines:
      print 'A line from the file:', line
\end{lstlisting}

But you can use a file object in a \s{for} loop to stream the lines as they're
read from the file:

\begin{lstlisting}
  f = open('mydata.txt')

  for line in f:
      print 'A line from the file:', line.rstrip()

  f.close()
\end{lstlisting}

Note that string data, like file objects, have methods attached ---
\s{rstrip()} in this case. This method returns a string that has had the
newline code (\s{`\textbackslash n'} from before) removed, which is needed for
this style of reading lines from a file.

Now, to be honest: modern machines have so much memory that it is almost
always fine to read in whole files at once. But if your file is a terabyte
large, or your ``file'' is a \i{never-ending} stream of data, streaming is an
important technique.

You can do some surprisingly sophisticated computations in the streaming
paradigm. As a relatively simple example, let's say that we want to compute
the mean $\langle M\rangle$ and variance $\sigma^2_M$ of the ``Mass'' column
of the data table we read in, which is a catalog of stars. If there are $N$
masses labeled $M_i$, these are defined as:
\[
\langle M\rangle = \frac{1}{N} \sum_{i = 1}^N M_i
\]
and
\[
\sigma^2_M = \frac{1}{N} \sum_{i = 1}^N (M_i - \langle M\rangle)^2,
\]
which can be implemented in Python thusly:

\begin{lstlisting}
  mass_col = table['Mass']
  mass_col = mass_col[~mass_col.mask] # drop rows without mass data
  x = 0.

  for i in range(len(mass_col)):
      x += mass_col[i] # same as: "x = x + mass_col[i]"

  mean_mass = x / len(mass_col)

  x = 0.

  for i in range(len(mass_col)):
      x += (mass_col[i] - mean_mass)**2

  mass_var = x / len(mass_col)
  mean_mass, mass_var
\end{lstlisting}

But you may recall this statistical identity:
\[
\sigma^2_M = \langle M^2\rangle - \langle M\rangle^2,
\]
which makes it possible to do the same computation like so:

\begin{lstlisting}
  m_sum = 0.
  m_sq_sum = 0.
  n = 0

  for mass in mass_col:
      m_sum += mass
      m_sq_sum += mass**2
      n += 1

  mean_mass = m_sum / n
  mass_var = m_sq_sum / n - mean_mass**2
  mean_mass, mass_var
\end{lstlisting}

Now in this particular example, the full table of data has been loaded into
memory, so we're not actually gaining anything. But our second, ``streaming''
approach \i{could} work with arbitrarily large tables, or ones whose size you
don't know in advance, while the first approach cannot.

We should also mention that the first example shows a coding style that you
should almost always avoid in Python: when working with lists of numbers, you
should use ``vectorized'' routines provided by the ``Numpy'' module. We're
tell you \i{much} more about this in the next session. However, while Numpy
gives much better tools for calculating the mean and variance of a vector of
data, it doesn't change the fundamental character of the approach, namely that
it requires the full vector to be stored in memory.


\newpage
\section{Modules and Functions}

In this hands-on activity we'll install and use a new Python package and
create your own modules and functions.

\subsection*{Installing a ``progress bar'' package}

Our goal is to create a module that provides a function that prints out a
``progress bar,'' showing how far some time-consuming task has progressed ---
say, a download of a large file.

Someone has surely already published a package that prints out a progress bar.
So, our first task is to survey the options. In a new web browser window,
navigate to the website \url{https://pypi.org/}. The ``PyPI'' is a centralized
database of a huge number of public Python packages. Run a search for
``progress bar'' to see what's available.

Yikes! There are literally \i{dozens} of options. This reflects a general
truth of software libraries: the easier it is to implement something, the more
different libraries there are to do it. Progress bars are very easy to
implement.

Our decision-making is made easier because we prefer to use the \s{conda}
package manager, which offers a much narrower selection of packages. Run the
following command in your terminal to survey \s{conda}'s offerings:

\typeone{conda search progress}{Search for Conda packages relating to ``progress''.}

It's not important to understand the output of this program in detail. One
thing that it is telling us, though, is that there is a package available
named \s{progressbar2}. That sounds promising.

Return to your web browser opened to \url{https://pypi.org/} and search
specifically for \s{progressbar2}. Click on the result for it --- being
careful because the search feature is a bit rough, and it doesn't put that one
package front-and-center.

There's a lot of information here. Scroll down to the ``Links'' section of the
page, which is about halfway down. Read over the list of links, noting that
one of them is to ``Documentation.'' Good: we don't want to waste our time
with software that doesn't come with a manual. But, to save time, we won't
look at the documentation right now.

Since this package meets our (very minimal) standards, let's go ahead and
install it. Go back to your terminal and run this command, hitting \s{Enter}
at the prompt to confirm the action:

\typeone{conda install progressbar2}{Install the ``progressbar2'' package.}

Now, return to your Jupyter notebook. We can load up the module right away.
Annoyingly, however, we must be careful because while the name of the
\i{package} we just installed is \s{progressbar2}, the name of the \i{Python
  module} provided by that package is just \s{progressbar}. This sort of thing
crops up often.

\begin{lstlisting}
  import progressbar
\end{lstlisting}

If no error message occurred, the import succeeded.

\subsection*{Writing your own module}

We'll now create our own module that will demonstrate the features of
\s{progressbar2}. Because we don't have time to develop a large piece of code,
our module will necessarily be small and silly, but it's good to practice the
process.

You can't use Jupyter to create modules, so we'll need to go back to the
terminal and \s{nano}. First, use \s{cd} to navigate to the directory where
your Jupyter notebook is being stored. Use \s{ls} to confirm that you're in
the right directory. It is \i{essential} for this exercise that you create the
module file in the same directory as your notebook.

Once you're sure that you're in the right directory, edit a new file:

\typeone{nano myfirstmodule.py}{Edit a new file.}

Fill in the following code --- again, this is to be typed \s{in nano} rather
than in your Jupyter notebook:

\begin{lstlisting}
  from __future__ import division # we don't have time to explain this
  from progressbar import ProgressBar
  import time

  string_variable = 'Hello from my module!'

  def demo_progressbar(n_steps, total_time_seconds):
      time_per_step = total_time_seconds / n_steps
      pb = ProgressBar(maxval=n_steps).start() # "keyword" function argument

      for i in range(n_steps):
          time.sleep(time_per_step)
          pb.update(i + 1)

      pb.finish()
\end{lstlisting}

Save your file to disk.

Back in your Jupyter notebook, you should be able to import your new module.
Again, we're switching back from \s{nano} to Jupyter.

\begin{lstlisting}
  import myfirstmodule
\end{lstlisting}

If there's no error message, everything worked. If there is an error, ask a
helper for assistance if you're at all unsure how to fix the problem.

The \s{dir()} function will return a list of the variables defined in your
module.

\begin{lstlisting}
  dir(myfirstmodule)
\end{lstlisting}

Note that this list includes not just your string variable, but also your
function, the other modules that your module imported, \i{and} some special
variables with names like \s{\_\_builtins\_\_} --- these are automatically
created by Python within every module.

Finally, let's use the code and data provided by our module!

\begin{lstlisting}
  print myfirstmodule.string_variable
  myfirstmodule.demo_progressbar(10, 5)
\end{lstlisting}

You should see a progress bar get filled up over the course of five seconds.

When doing real work, if you're making a module you probably want to reuse it
in multiple projects. The approach that we just demonstrated is \i{not}
desirable in those situations. Instead, you would create a \s{git} repository
to track your module's development and write a special ``\s{setup.py}'' script
allowing you to install it into your Python system's list of libraries. We
don't have time to explain that whole process here, but there are many
tutorials available online.


\newpage
\section*{Other Resources}

Many, many people have written many, many books aimed at beginning
programmers. Many of them are about Python and will be absolutely relevant to
you. Here are a few that you might want to check out.

\i{How to Think Like a Computer Scientist: Learning with Python}, by Allen
Downey, Jeffrey Elkner, and Chris Meyers. A 280-page textbook freely
downloadable from:
\url{http://www.greenteapress.com/thinkpython/thinkCSpy/thinkCSpy.pdf}. The
book's Appendix~C contains its own list of recommended readings and resources.

\i{A Gentle Introduction to Programming Using Python}. A freely-available
four-week online course from MIT, patterned after \i{How to Think Like a
  Computer Scientist}. The course homepage is at this shortened Web address:
\url{http://bit.ly/2d9V62A}.

A lot of people fail to appreciate the value of just sitting down and
\i{reading the detailed specification} of a language. A good spec is like a
good math textbook --- dense and dry, but brimming with insights for the
engaged reader. The Python~2 spec is here:
\url{https://docs.python.org/2/reference/}.

The other thing that people fail to appreciate is the value of \i{reading
  code}. In a course teaching a human language like French, you'll probably
read \i{at least} ten times as much as you write. Learning a programming
language should be the same! Read the code behind the modules you use,
especially large, mature ones like AstroPy:
\url{https://github.com/astropy/astropy/}.

The for-profit company Codecademy offers a popular, free Python course at
\url{https://www.codecademy.com/learn/python}. It has you type Python code
live into your browser, like the Jupyter notebooks that we use.

Google has a Python class for ``people with a little bit of programming
experience'' that may be found online here:
\url{https://developers.google.com/edu/python/}. It includes video lectures
and exercises.

The \href{https://software-carpentry.org/}{Software Carpentry} project aims to
teach programming to scientists who might not have a strong computing
background. Their lessons are intended to be conducted live, but the materials
are available online at
\url{http://swcarpentry.github.io/python-novice-inflammation/}. That
particular lesson is intended to take about five hours to finish. Please note
that the lesson targets \i{version~3} of Python, while we are targeting
version~2, which is similar but incompatible.

The website \href{https://stackoverflow.com/}{StackOverflow} probably already
contains the answer to any Python question you might ever ask. Its section of
Python-related questions may be found at
\url{https://stackoverflow.com/questions/tagged/python}.

Finally, if you go ahead and do a web search for ``how to learn Python,'' you
will get an enormous list of resources. Many of them are from companies trying
to make a few bucks off of the many people who want to learn how to code, and
not all of their offerings will be brilliant. But there are surely gems out
there that we haven't listed above.


\end{document}


% The boneyard %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
  print 'A:', len(list_of_ints)
  a_list_of_ints.append(8)
  print 'B:', list_of_ints
\end{lstlisting}

Here we are using the \s{print} statement to output the values of the various
\i{expressions} that we've typed on those lines, so that we don't have to make
lots of tiny little notebook cells to see what's happening. The ``A:'' markers
help clarify which printed-out value corresponds to which expression.

Above, \s{len()} is a function that returns the length of a list, and
\s{.append()} is a function that adds an item to the end of a list --- namely,
the list that appears to the left of the dot. Why does \s{append} use a dot,
but not \s{len}? Why is \s{print} not a function like \s{len}? The honest
answer: Python was designed in a kind of sloppy way!

\subsection*{Sets}

Python's \i{sets} are like mathematical sets: unordered collections of
objects, without duplication. Sets can combine different types of data, but
usually they should contain just one type.

\begin{lstlisting}
  a_set = {1, 5, 10, 15}
  empty_set = set() # note: "{}" doesn't work
  list_converted_to_set = set(a_list_of_ints)
  print a_list_of_ints
  print list_converted_to_set
\end{lstlisting}

Because sets are unordered, you cannot index them. If you want to get a set's
items back out, often it is helpful to convert it into a list with the
\t{list()} function --- keeping in mind that \i{the list you get back will be
  given to you in an unpredictable order}.

\begin{lstlisting}
  a_set[0] # !!! raises TypeError
\end{lstlisting}

\begin{lstlisting}
  print list(a_set) # does the output match the order you typed in before?
\end{lstlisting}

Here are some things you can do with sets:

\begin{lstlisting}
  print 'A:', len(empty_set)
  print 'B:', (1 in a_set) # these parentheses are not stricly needed
  print 'C:', (17 in a_set) # but hopefully they clarify what's happening
  print 'D:', (17 not in a_set)
  a_set.add(17)
  print 'E:', (17 not in a_set)
\end{lstlisting}

Because of this latter constraint, you can only
construct sets of certain kinds of data; mutable data are not allowed, because
you could mutate them to break the constraint.

\subsection*{Dictionaries}

Finally, \i{dictionaries} (usually shortened to \i{dicts}) are unordered
collections of pairs of unique \i{keys} associated with possibly-non-unique
\i{values}. Given a key, it is easy to fetch a value, but the opposite is not
true. Relatedly, because dictionary keys must be unique, they have to follow
the same constraints as set items. Dictionary values do not have this
constraint.

\begin{lstlisting}
  a_dict = {'key1': 'value1', 'key2': 'value2'}
  other_dict = {1: [1, 2, 3], -37: None}
  dict_with_string_keys = dict(key1='value1', key2='value2')
  empty_dict = {} # this syntax always gives you a dict, not a set
\end{lstlisting}

To look up a value in a dict, you index it, using the same typed syntax as you
do for a list. You can use variable-assignment syntax to add new entries to
dicts. You can use ``\s{del} syntax'' to remove entries.

\begin{lstlisting}
  print(a_dict['key1'])
  print(len(a_dict))
  a_dict['newkey'] = 'newvalue'
  print(len(a_dict))
  del a_dict['key1']
  print(len(a_dict))
  print(list(other_dict.keys()))
  print(list(other_dict.values()))
\end{lstlisting}

The three basic structures provided by Python are \i{not} the only ones out
there, and they are not necessarily ``fundamental'' in any deep sense. For
instance, lists can be thought of as dicts where the keys are integers
starting at zero. Likewise, sets can be thought of as dicts where the values
are all \s{True}.

\subsection*{Mutability in action}

In the mini-lecture, we emphasized the importance of \i{mutability} and
\i{ownership} when thinking about data. The basic data structures are mutable,
so they can change from under you in surprising ways. Try hard to understand
what happens when you run this small example:

\begin{lstlisting}
  my_list = [1, 2, 3]
  print(my_list)
  other_list = my_list # "other_list" is a new name for the same data
  other_list.append(37)
  print(my_list)
\end{lstlisting}

The foundational data types are all immutable, so they are not susceptible to
these kinds of surprises.

Python does, however, provide versions of its data structures that are
immutable after creation. The immutable version of a list is called a
\i{tuple}. It is usually written with parentheses. However, in many cases the
parentheses are actually optional!

\begin{lstlisting}
  a_tuple = (0, 3, 4)
  equivalent_tuple = 0, 3, 4
  other_tuple = (a_dict, 'hello', empty_set)
  empty_tuple = ()
\end{lstlisting}

In Python, the syntax \s{(x)} is interpreted as mathematical grouping. To
create a tuple with one element, you must use a special syntax:

\begin{lstlisting}
  one_item_tuple = (True,)
\end{lstlisting}

Because of mutability, lists cannot be used as dictionary keys, but tuples can:

\begin{lstlisting}
  my_dict = {}
  my_dict[(1,2,3)] = 'hello'
  my_dict[1,2,4] = 'goodbye' # tuple parentheses can be omitted here
  print(my_dict)
  my_dict[[1,2,5]] = 'problem' # !!! raises TypeError
\end{lstlisting}

You can generally access and index tuples as you would lists. While you cannot
modify tuples' contents directly, tuples \i{can} contain data structures that
are themselves mutable:

\begin{lstlisting}
  print(other_tuple)
  a_dict['morekey'] = 'edited'
  print(other_tuple)
\end{lstlisting}

Because of this fact, tuples containing mutable data structures
\i{cannot} be used as keys for dictionaries or sets.

\begin{lstlisting}
  my_dict[other_tuple] = 'problem' # !!! raises TypeError
\end{lstlisting}

The immutable version of a set is called a \s{frozenset}. There is no
built-in syntax to create frozen sets. You must instead create them with the
\s{frozenset()} function. This function takes one argument that is a
collection, so be careful with parentheses.

\begin{lstlisting}
  frozen_from_list = frozenset([1, 2, 3])
  some_tuple = (4, 5, 6)
  frozen_from_tuple = frozenset(some_tuple)
  frozen_from_equivalent_tuple = frozenset((4, 5, 6))
  too_many_arguments = frozenset(4, 5, 6) # !!! raises TypeError
\end{lstlisting}

There is no built-in immutable version of a \s{dict}.

\subsection*{Choosing the Right Data Structure}

In realistic programs it is \i{exceedingly} important to choose the right data
structure for your job. Fortunately, Python's foundational structures are very
flexible and can gracefully handle all sorts of tasks. But there are more
choices to be made than you might initially think.

For example, say that your program works with radio measurements. Each
measurement (\s{m}) is tagged with a time (\s{t}), a frequency (\s{f}), and a
polarization (\s{p}). Here are some ways that you could store a collection of
measurements:

\begin{itemize}
\item A list of tuples, each tuple of the form \s{(t, f, p, m)}. Each
  polarization is encoded as a string: \s{"nn"}, \s{"ee"}, \s{"ne"}, or
  \s{"en"}.
\item The same as the above, except the polarizations are encoded as the
  integers 0--3 instead of strings.
\item A dict of lists, where the dict keys are the four polarizations
  (\s{"nn"}, etc.), and the lists are made of tuples \s{(t, f, m)}.
\item The same as the above, but the dict keys are the timestamps
  (\s{t}), and the lists are made of tuples \s{(f, p, m)}.
\item A tuple of four lists: one of all the timestamps, one of frequencies,
  one of polarizations, and one of measurements.
\item A dict of dicts of dicts of floats, where the outermost keys are times,
  then frequencies, then polarizations, and the final values are the
  measurements.
\end{itemize}

Which of these is the best? It depends on the characteristics of your data and
what task you're trying to accomplish. When deciding how to represent your data in
Python structures, think about these factors:

\begin{enumerate}
\item Which choice will help me write the simplest, clearest code?
\item Which choice will result in the fastest program?
\item Which choice will result in the most memory-efficient program?
\end{enumerate}

Generally, the first consideration is the most important and the last is the
least important. When you're dealing with large data sets, however, you may
have to trade off code complexity for efficiency.

Very similar considerations apply when writing data to disk and reading them
again. The file format that you use to save data also involves tradeoffs for
speed, efficiency, convenience, and so on. It is \i{very common} to see people
spend a lot of time wrestling with code that reads and writes data because the
file format they are using is not well-matched to the problem they are trying
to solve. If you're having trouble doing what you want with a data set, don't
forget to ask yourself: \i{is the problem in the code, or in the data
  structure}?
